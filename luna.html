<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Luna en AR - Demo con flechas</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; background: black;
    height: 100%; width: 100%;
    font-family: sans-serif;
    color: white;
  }
  #videoElement {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    object-fit: cover;
    z-index: 0;
  }
  #overlay {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 1;
    pointer-events: none;
  }
  #info {
    position: fixed;
    bottom: 5px; left: 5px;
    z-index: 2;
    background: rgba(0,0,0,0.5);
    padding: 6px 12px;
    border-radius: 8px;
    font-size: 14px;
  }
</style>
</head>
<body>

<video id="videoElement" autoplay playsinline></video>
<canvas id="overlay"></canvas>
<div id="info">Punto rojo = posición aproximada de la luna</div>

<script src="https://cdn.jsdelivr.net/npm/suncalc@1.9.0/suncalc.js"></script>
<script>
(async () => {
  const video = document.getElementById('videoElement');
  const canvas = document.getElementById('overlay');
  const ctx = canvas.getContext('2d');
  const info = document.getElementById('info');

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment" },
      audio: false
    });
    video.srcObject = stream;
  } catch (e) {
    info.textContent = "Error accediendo a la cámara: " + e.message;
    return;
  }

  function getPosition() {
    return new Promise((res, rej) => {
      if (!navigator.geolocation) {
        rej("Geolocalización no soportada");
      } else {
        navigator.geolocation.getCurrentPosition(pos => {
          res({ lat: pos.coords.latitude, lon: pos.coords.longitude });
        }, err => {
          rej("No se pudo obtener ubicación: " + err.message);
        }, { enableHighAccuracy: true, timeout: 10000 });
      }
    });
  }

  let lat, lon;
  try {
    const pos = await getPosition();
    lat = pos.lat;
    lon = pos.lon;
  } catch (e) {
    info.textContent = e;
    return;
  }

  info.textContent = "Apunta el celular hacia el cielo para ver la luna (círculo rojo).";

  let alpha = 0, beta = 0, gamma = 0;

  window.addEventListener('deviceorientation', (event) => {
    alpha = event.alpha || 0;
    beta = event.beta || 0;
    gamma = event.gamma || 0;
  }, true);

  const toRad = deg => deg * Math.PI / 180;
  const toDeg = rad => rad * 180 / Math.PI;

  function getMoonPos(date, lat, lon) {
    const moonPos = SunCalc.getMoonPosition(date, lat, lon);
    return {
      azimuth: moonPos.azimuth,
      altitude: moonPos.altitude
    };
  }

  // Dibujar flecha apuntando en dirección (x,y) desde centro de pantalla
  // size controla tamaño base
  function drawArrow(x, y, angle, size = 40, color = 'rgba(255,0,0,0.8)') {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(0, -size);
    ctx.lineTo(size * 0.6, size);
    ctx.lineTo(0, size * 0.4);
    ctx.lineTo(-size * 0.6, size);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function mapMoonToScreen(azimuth, altitude, alpha, beta) {
    const alphaRad = toRad(alpha);
    let deltaAz = azimuth - alphaRad;
    if (deltaAz > Math.PI) deltaAz -= 2 * Math.PI;
    if (deltaAz < -Math.PI) deltaAz += 2 * Math.PI;

    const horizontalFOV = Math.PI / 2; // 90 grados
    const verticalFOV = Math.PI / 2;

    // Diferencia vertical
    const deltaAlt = altitude - toRad(beta);

    // Si dentro del rango, devolvemos coords en pantalla
    if (Math.abs(deltaAz) <= horizontalFOV / 2 && deltaAlt >= -verticalFOV / 2 && deltaAlt <= verticalFOV / 2) {
      const x = (canvas.width / 2) + (deltaAz / (horizontalFOV / 2)) * (canvas.width / 2);
      const y = (canvas.height / 2) - (deltaAlt / (verticalFOV / 2)) * (canvas.height / 2);
      return { visible: true, x, y };
    } else {
      // Fuera de rango, calcular posición para flecha en borde
      // Calculamos el ángulo en pantalla donde debería apuntar la luna
      // Usamos deltaAz para la dirección horizontal, y deltaAlt para vertical
      // Simplificamos: el vector apunta desde centro hacia (deltaAz, deltaAlt)

      // Normalizamos deltaAz y deltaAlt al rango -1..1
      let normX = deltaAz / (horizontalFOV / 2);
      let normY = -deltaAlt / (verticalFOV / 2); // invertido para pantalla

      // Limitar normX y normY a [-1.5,1.5] para evitar flechas muy lejanas
      normX = Math.max(-1.5, Math.min(1.5, normX));
      normY = Math.max(-1.5, Math.min(1.5, normY));

      // Calculamos el ángulo desde el centro
      const angle = Math.atan2(normY, normX);

      // Posición en borde del canvas con un margen de 30 px
      const margin = 30;
      const w = canvas.width;
      const h = canvas.height;
      const cx = w / 2;
      const cy = h / 2;

      // Encontrar punto en el borde siguiendo ángulo
      // Calculo de intersección con rectángulo
      const tanAngle = Math.tan(angle);

      let x = 0, y = 0;
      if (angle >= -Math.PI / 4 && angle <= Math.PI / 4) {
        // Derecho
        x = w - margin;
        y = cy - (w / 2 - margin) * tanAngle;
      } else if (angle > Math.PI / 4 && angle < 3 * Math.PI / 4) {
        // Arriba
        y = margin;
        x = cx + (cy - margin) / tanAngle;
      } else if (angle >= 3 * Math.PI / 4 || angle <= -3 * Math.PI / 4) {
        // Izquierda
        x = margin;
        y = cy + (w / 2 - margin) * tanAngle;
      } else {
        // Abajo
        y = h - margin;
        x = cx - (cy - margin) / tanAngle;
      }

      // Limitamos x,y para que estén dentro del canvas
      x = Math.max(margin, Math.min(w - margin, x));
      y = Math.max(margin, Math.min(h - margin, y));

      // Tamaño de flecha proporcional a distancia angular (máx 40)
      const dist = Math.min(1.5, Math.sqrt(normX * normX + normY * normY));
      const size = 20 + 20 * dist;

      return { visible: false, x, y, angle, size };
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const now = new Date();
    const moonPos = getMoonPos(now, lat, lon);
    const screenPos = mapMoonToScreen(moonPos.azimuth, moonPos.altitude, alpha, beta);

    if (screenPos.visible) {
      // Dibujar punto rojo en la luna
      ctx.beginPath();
      ctx.arc(screenPos.x, screenPos.y, 20, 0, 2 * Math.PI);
      ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
      ctx.fill();
      ctx.lineWidth = 3;
      ctx.strokeStyle = 'white';
      ctx.stroke();
    } else {
      // Dibujar flecha apuntando a luna
      drawArrow(screenPos.x, screenPos.y, screenPos.angle, screenPos.size);

      // Mostrar texto direccional simple
      const marginText = 10;
      ctx.fillStyle = 'white';
      ctx.font = '16px sans-serif';

      // Basado en screenPos.angle indicamos dirección cardinal simplificada
      let dir = "";
      const deg = (screenPos.angle * 180 / Math.PI + 360) % 360;
      if (deg >= 337.5 || deg < 22.5) dir = "Derecha";
      else if (deg >= 22.5 && deg < 67.5) dir = "Arriba-Derecha";
      else if (deg >= 67.5 && deg < 112.5) dir = "Arriba";
      else if (deg >= 112.5 && deg < 157.5) dir = "Arriba-Izquierda";
      else if (deg >= 157.5 && deg < 202.5) dir = "Izquierda";
      else if (deg >= 202.5 && deg < 247.5) dir = "Abajo-Izquierda";
      else if (deg >= 247.5 && deg < 292.5) dir = "Abajo";
      else if (deg >= 292.5 && deg < 337.5) dir = "Abajo-Derecha";

      ctx.textAlign = "center";
      ctx.fillText(dir, screenPos.x, screenPos.y - screenPos.size - marginText);
    }

    requestAnimationFrame(draw);
  }

  draw();

})();
</script>

</body>
</html>
