<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Luna AR con Sensor API</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; background: black;
    height: 100%; width: 100%;
    font-family: sans-serif;
    color: white;
  }
  #videoElement {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    object-fit: cover;
    z-index: 0;
  }
  #overlay {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 1;
    pointer-events: none;
  }
  #info {
    position: fixed;
    bottom: 5px; left: 5px;
    z-index: 2;
    background: rgba(0,0,0,0.5);
    padding: 6px 12px;
    border-radius: 8px;
    font-size: 14px;
  }
</style>
</head>
<body>

<video id="videoElement" autoplay playsinline></video>
<canvas id="overlay"></canvas>
<div id="info">Apunta el celular hacia el cielo para ver la luna (círculo rojo)</div>

<script src="https://cdn.jsdelivr.net/npm/suncalc@1.9.0/suncalc.js"></script>
<script>
(async () => {
  const video = document.getElementById('videoElement');
  const canvas = document.getElementById('overlay');
  const ctx = canvas.getContext('2d');
  const info = document.getElementById('info');

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  // Acceso cámara trasera
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment" },
      audio: false
    });
    video.srcObject = stream;
  } catch (e) {
    info.textContent = "Error accediendo a la cámara: " + e.message;
    return;
  }

  // Obtener ubicación
  function getPosition() {
    return new Promise((res, rej) => {
      if (!navigator.geolocation) {
        rej("Geolocalización no soportada");
      } else {
        navigator.geolocation.getCurrentPosition(pos => {
          res({ lat: pos.coords.latitude, lon: pos.coords.longitude });
        }, err => {
          rej("No se pudo obtener ubicación: " + err.message);
        }, { enableHighAccuracy: true, timeout: 10000 });
      }
    });
  }

  let lat, lon;
  try {
    const pos = await getPosition();
    lat = pos.lat;
    lon = pos.lon;
  } catch (e) {
    info.textContent = e;
    return;
  }

  info.textContent = "Apunta el celular hacia el cielo para ver la luna (círculo rojo)";

  // --- Funciones para manejar quaternion y orientación ---

  // Convierte un quaternion a ángulo azimut y elevación respecto al norte y horizonte
  // Basado en sistema de coordenadas del dispositivo y del mundo
  function quaternionToAzEl(q) {
    // q = [x,y,z,w]
    // Convertir quaternion a matriz de rotación 3x3
    const [x, y, z, w] = q;
    const R = [
      1 - 2*y*y - 2*z*z,   2*x*y - 2*z*w,       2*x*z + 2*y*w,
      2*x*y + 2*z*w,       1 - 2*x*x - 2*z*z,   2*y*z - 2*x*w,
      2*x*z - 2*y*w,       2*y*z + 2*x*w,       1 - 2*x*x - 2*y*y
    ];

    // El vector que apunta hacia el "frente" del dispositivo en coordenadas mundo es la 3ra columna de R inversa
    // O, para el cálculo del azimut y elevación, usamos el vector "down" en sistema mundo y calculamos su dirección relativa

    // Vamos a tomar el vector (0,0,-1) en coords dispositivo (mirando hacia adelante)
    // Transformado a coords mundo por la matriz R
    // La dirección donde apunta el dispositivo es:
    const vx = -R[6];
    const vy = -R[7];
    const vz = -R[8];

    // Azimut (ángulo horizontal respecto norte, 0=norte, positivo hacia este)
    // azimuth = atan2(vx, vy)
    const azimuth = Math.atan2(vx, vy);

    // Elevación (ángulo vertical sobre el horizonte)
    // elevación = asin(vz)
    const elevation = Math.asin(vz);

    return { azimuth, elevation };
  }

  // Obtener quaternion del sensor y actualizar orientación
  let currentAzimuth = 0;
  let currentElevation = 0;

  // Verificamos soporte Sensor API
  if ('AbsoluteOrientationSensor' in window) {
    const sensor = new AbsoluteOrientationSensor({ frequency: 30, referenceFrame: 'device' });
    sensor.addEventListener('reading', () => {
      const q = sensor.quaternion;
      const { azimuth, elevation } = quaternionToAzEl(q);
      currentAzimuth = azimuth;
      currentElevation = elevation;
    });
    sensor.addEventListener('error', event => {
      info.textContent = "Error sensor: " + event.error.name;
    });
    sensor.start();
  } else {
    info.textContent = "Sensor AbsoluteOrientationSensor no soportado en este navegador.";
    return;
  }

  // Librería suncalc para posición luna
  function getMoonPos(date, lat, lon) {
    const moonPos = SunCalc.getMoonPosition(date, lat, lon);
    return {
      azimuth: moonPos.azimuth,
      altitude: moonPos.altitude
    };
  }

  // Mapear la posición de la luna en coordenadas de pantalla según orientación
  function mapMoonToScreen(moonAz, moonAlt, deviceAz, deviceEl) {
    // Diferencia entre luna y orientación actual
    let deltaAz = moonAz - deviceAz;
    if (deltaAz > Math.PI) deltaAz -= 2 * Math.PI;
    if (deltaAz < -Math.PI) deltaAz += 2 * Math.PI;

    let deltaAlt = moonAlt - deviceEl;

    // Campo de visión (en radianes)
    const horizontalFOV = Math.PI / 2; // 90 grados
    const verticalFOV = Math.PI / 2;

    // Si está fuera del rango horizontal o vertical, no mostrar
    if (Math.abs(deltaAz) > horizontalFOV / 2 || deltaAlt < -verticalFOV / 2 || deltaAlt > verticalFOV / 2) {
      return null;
    }

    // Mapeo a píxeles
    const x = (canvas.width / 2) + (deltaAz / (horizontalFOV / 2)) * (canvas.width / 2);
    const y = (canvas.height / 2) - (deltaAlt / (verticalFOV / 2)) * (canvas.height / 2);
    return { x, y };
  }

  // Dibujar círculo rojo en (x,y)
  function drawMoonMarker(x, y) {
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, 2 * Math.PI);
    ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
    ctx.fill();
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'white';
    ctx.stroke();
  }

  // Loop de dibujo
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const now = new Date();
    const moonPos = getMoonPos(now, lat, lon);

    const screenPos = mapMoonToScreen(moonPos.azimuth, moonPos.altitude, currentAzimuth, currentElevation);

    if (screenPos) {
      drawMoonMarker(screenPos.x, screenPos.y);
      info.textContent = "Luna visible: apunta hacia el círculo rojo.";
    } else {
      info.textContent = "Luna fuera de campo de visión. Apunta el celular hacia ella.";
    }

    requestAnimationFrame(draw);
  }

  draw();

})();
</script>

</body>
</html>
